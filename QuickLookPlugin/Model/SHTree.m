#import "SHTree.h"#import "SHTreeObject.h"/* The method generate returns an array of SHTreeObject which is a sub-class  of BaseTreeObject. This array is the "Content Array" bind to the NSTreeController object. */@implementation SHTree/* "flatTreeObjects" is an array of SHTreeObject objects created whenever the model tree structure managed by an instance of NSTreeController needs to be built or rebuilt. The aim is to return an array of root objects of class SHTreeObject. This array can be passed to an instance of NSTreeController either thru Cocoa binding or programmatically using the method insertObject:atArrangedObjectIndexPath. To facilitate the building of a tree whose roots are attached at sub-trees to a  main tree, the "pathNames" property of SHTreeObject is not prepended with a slash. Before generating the multi-rooted tree, we may use the NSArray method sortUsingSelector: to arrange the path names in case they are not in alphabetical order. This will ensure the pathNames of the tree objects are in pre-order arrangement. */// Unused method+(SHTreeObject *) buildSingleRoot:(NSMutableArray *)flatListOfTreeObjects {    SHTreeObject *rootObject = [SHTreeObject rootTreeObject];	// The above SHTreeObject method should have set "rootObject" to autorelease.	NSEnumerator *enumerator = [flatListOfTreeObjects objectEnumerator];	id anObject = nil;    // Create a single-rooted tree using the array of SHTreeObjects.	while (anObject = [enumerator nextObject]) {		[anObject addToRootObject:rootObject];	}		NSMutableArray *rootObjectsArray = [NSMutableArray array];	// set to autorelease	if ([[rootObject children] count] != 0) {		// We are only interested in the top level (root) tree objects.		for (SHTreeObject *child in [rootObject children]) {			[rootObjectsArray addObject:child];				child.parentObject = nil;		}	}	return rootObject;}// Build a multi-rooted tree of SHTreeObjects.+(NSMutableArray *) buildMultipleRoots:(NSMutableArray *)flatListOfTreeObjects {    SHTreeObject *rootObject = [SHTreeObject rootTreeObject];	NSEnumerator *enumerator = [flatListOfTreeObjects objectEnumerator];	id anObject = nil;    while (anObject = [enumerator nextObject]) {		[anObject addToRootObject:rootObject];	}	NSMutableArray *rootObjectsArray = [NSMutableArray array];	if ([[rootObject children] count] != 0) {		// We are only interested in the top level (root) tree objects.		for (SHTreeObject *child in [rootObject children]) {			[rootObjectsArray addObject:child];			child.parentObject = nil;	// This might be important.		}	}	// The returned array are the roots of a multi-rooted tree.	// The roots can be treated as those of an entire tree	// or can be attached as sub-trees to a main tree.	return rootObjectsArray;}/* Visit node first then its children (if any) - pre-order */+ (void) visitNode:(SHTreeObject *)treeObj {    if (treeObj != nil) {		printf("%s\n", [treeObj.pathName cStringUsingEncoding:NSMacOSRomanStringEncoding]);		for (int i=0; i < [[treeObj children] count]; i++) {			SHTreeObject *childNode = [[treeObj children] objectAtIndex:i];			[self visitNode:childNode];		}	}}/* We need the proxy root object which can be obtained by sending a message like  id proxyRoot = [self.treeController arrangedObjects]; Then setup to send a message visitNode to each child of the proxy root NSArray *children = [proxyRoot childNodes]; for (int i=0; i < [children count]; i++)	[self visitNode:[children objectAtIndex:i]]; This method was for debugging purposes; the rootObjects array has been released in one of the the document methods. */// Unused+ (void) print:(NSArray *)rootObjects {    for (SHTreeObject *treeObj in rootObjects) {		[[self class] visitNode:treeObj];	}}@end